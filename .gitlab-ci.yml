stages:
  - build
  - docker
  - release
  - deploy

variables:
  IMAGE_NAME: high-command-ui
  K8S_NAMESPACE: high-command
  DEPLOYMENT_NAME: high-command-ui

build:
  stage: build
  image: harbor.dataknife.net/dockerhub/library/node:20-slim
  script:
    - apt-get update && apt-get install -y --no-install-recommends make git
    - make build
  artifacts:
    paths:
      - dist/
      - node_modules/.cache/
    expire_in: 1 hour
  rules:
    - if: '$CI_COMMIT_TAG'  # Run on any git tag
    - if: '$CI_COMMIT_TAG'
  tags:
    - kubernetes

publish:
  stage: docker
  image:
    name: moby/buildkit:rootless
    entrypoint: [""]
  dependencies:
    - build
  script:
    - |
      # Use commit SHA if available, otherwise fall back to pipeline ID
      IMAGE_TAG="${CI_COMMIT_SHORT_SHA:-$CI_PIPELINE_ID}"
      
      # Build and push images with BuildKit rootless (multiple outputs for multiple tags)
      OUTPUT_FLAGS="--output type=image,name=$HARBOR_REGISTRY/$HARBOR_PROJECT/$IMAGE_NAME:latest,push=true"
      OUTPUT_FLAGS="$OUTPUT_FLAGS --output type=image,name=$HARBOR_REGISTRY/$HARBOR_PROJECT/$IMAGE_NAME:$IMAGE_TAG,push=true"
      
      # Add version tag if tag exists
      if [ -n "$CI_COMMIT_TAG" ]; then
        OUTPUT_FLAGS="$OUTPUT_FLAGS --output type=image,name=$HARBOR_REGISTRY/$HARBOR_PROJECT/$IMAGE_NAME:$CI_COMMIT_TAG,push=true"
      fi
      
      buildctl-daemonless.sh build \
        --frontend dockerfile.v0 \
        --local context=. \
        --local dockerfile=. \
        $OUTPUT_FLAGS
  rules:
    - if: '$CI_COMMIT_TAG'  # Run on any git tag
  tags:
    - kubernetes

release:
  stage: release
  image: registry.gitlab.com/gitlab-org/cli:latest
  dependencies:
    - build
  rules:
    - if: $CI_COMMIT_TAG
      when: never                                  # Do not run this job when a tag is created manually
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH  # Run this job when commits are pushed or merged to the default branch
  script:
    - |
      echo "Creating release for commit $CI_COMMIT_SHORT_SHA"
      echo "Release will create tag automatically"
  release:                               # See https://docs.gitlab.com/ee/ci/yaml/#release for available properties
    tag_name: 'v0.$CI_PIPELINE_IID'     # The version is incremented per pipeline
    description: 'Release v0.$CI_PIPELINE_IID'
    ref: '$CI_COMMIT_SHA'                # The tag is created from the pipeline SHA
  tags:
    - kubernetes

deploy:
  stage: deploy
  image: harbor.dataknife.net/dockerhub/library/bitnami/kubectl:latest
  dependencies:
    - publish
  variables:
    KUBECONFIG: /tmp/kubeconfig
  before_script:
    - |
      # Write kubeconfig from GitLab variable
      echo "$PRD_APPS_KUBECONFIG" | base64 -d > $KUBECONFIG
      chmod 600 $KUBECONFIG
      kubectl config use-context prd-apps || kubectl config get-contexts | head -5
  script:
    - |
      # Only deploy on semantic version tags
      if [ "$CI_COMMIT_BRANCH" != "main" ] && ! [[ "$CI_COMMIT_TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        echo "Not a semantic version tag. Skipping deployment."
        exit 0
      fi
      
      echo "Starting blue/green deployment for $DEPLOYMENT_NAME in $K8S_NAMESPACE on prd-apps cluster"
      
      # Decode Kubeconfig
      mkdir -p ~/.kube
      echo "$PRD_APPS_KUBECONFIG" | base64 -d > ~/.kube/config
      chmod 600 ~/.kube/config
      export KUBECONFIG=~/.kube/config
      
      # Verify kubectl access
      kubectl cluster-info
      kubectl get nodes
      
      # Determine current active color (blue or green)
      CURRENT_COLOR=$(kubectl get service $DEPLOYMENT_NAME -n $K8S_NAMESPACE -o jsonpath='{.spec.selector.deployment-color}' 2>/dev/null || echo "blue")
      NEW_COLOR="blue"
      if [ "$CURRENT_COLOR" == "blue" ]; then
        NEW_COLOR="green"
      fi
      
      echo "Current active color: $CURRENT_COLOR"
      echo "Deploying new version as: $NEW_COLOR"
      
      # Get image tag from publish stage
      IMAGE_TAG="${CI_COMMIT_SHORT_SHA:-$CI_PIPELINE_ID}"
      if [ -n "$CI_COMMIT_TAG" ]; then
        IMAGE_TAG="$CI_COMMIT_TAG"
      fi
      IMAGE_REF="$HARBOR_REGISTRY/$HARBOR_PROJECT/$IMAGE_NAME:$IMAGE_TAG"
      
      echo "Deploying image: $IMAGE_REF"
      
      # Apply new deployment (blue or green)
      cat <<EOFDEPLOY | kubectl apply -f -
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: ${DEPLOYMENT_NAME}-${NEW_COLOR}
        namespace: $K8S_NAMESPACE
        labels:
          app: $DEPLOYMENT_NAME
          deployment-color: $NEW_COLOR
      spec:
        replicas: 2
        selector:
          matchLabels:
            app: $DEPLOYMENT_NAME
            deployment-color: $NEW_COLOR
        template:
          metadata:
            labels:
              app: $DEPLOYMENT_NAME
              deployment-color: $NEW_COLOR
          spec:
            imagePullSecrets:
            - name: harbor-registry-secret
            containers:
            - name: $DEPLOYMENT_NAME
              image: $IMAGE_REF
              ports:
              - containerPort: 3000
              env:
              - name: NODE_ENV
                value: "production"
              - name: PORT
                value: "3000"
              livenessProbe:
                httpGet:
                  path: /
                  port: 3000
                initialDelaySeconds: 10
                periodSeconds: 30
                timeoutSeconds: 5
                successThreshold: 1
                failureThreshold: 3
              readinessProbe:
                httpGet:
                  path: /
                  port: 3000
                initialDelaySeconds: 5
                periodSeconds: 10
                timeoutSeconds: 3
                successThreshold: 1
                failureThreshold: 2
              resources:
                requests:
                  cpu: "100m"
                  memory: "128Mi"
                limits:
                  cpu: "500m"
                  memory: "512Mi"
      EOFDEPLOY
      
      echo "Waiting for ${DEPLOYMENT_NAME}-${NEW_COLOR} deployment to be ready..."
      kubectl rollout status deployment/${DEPLOYMENT_NAME}-${NEW_COLOR} -n $K8S_NAMESPACE --timeout=5m
      
      echo "Switching service selector to new deployment: ${DEPLOYMENT_NAME}-${NEW_COLOR}"
      # Patch the service to point to the new deployment
      kubectl patch service $DEPLOYMENT_NAME -n $K8S_NAMESPACE -p "{\"spec\":{\"selector\":{\"deployment-color\":\"$NEW_COLOR\"}}}"
      
      echo "Waiting for service to update..."
      sleep 10 # Give some time for service to update endpoints
      
      # Scale down old deployment (keep for quick rollback)
      if [ "$CURRENT_COLOR" != "blue" ] || kubectl get deployment ${DEPLOYMENT_NAME}-${CURRENT_COLOR} -n $K8S_NAMESPACE 2>/dev/null | grep -q ${DEPLOYMENT_NAME}-${CURRENT_COLOR}; then
        echo "Scaling down old deployment ${DEPLOYMENT_NAME}-${CURRENT_COLOR}..."
        kubectl scale deployment ${DEPLOYMENT_NAME}-${CURRENT_COLOR} -n $K8S_NAMESPACE --replicas=0
      fi
      
      echo "âœ“ Deployment complete. ${DEPLOYMENT_NAME}-${NEW_COLOR} is now serving traffic."
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+$/'  # Only run this job when a semantic version tag is created
  tags:
    - kubernetes
  variables:
    GIT_STRATEGY: none # No need to clone repo again
